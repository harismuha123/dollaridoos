import { Component } from '@angular/core';
import { Http, RequestOptions, Response } from '@angular/http';

interface ResponseType {
  convertedAmount: number;
  fromCurrency: string;
  toCurrency: string;
  amount: number;
}

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {

  private http: Http;
  private currencyType: ResponseType;
  private value: ResponseType;
  private initialValue: number;
  private finalValue: number;
  private initialKey: string;
  private finalKey: string;

  // This will hold a text with last error
  private lastError: string;

  constructor(http: Http) {
    this.http = http;
    this.http.get('http://localhost:5000/converter/list').subscribe((res) => {
      this.currencyType = res.json();
    });
  }


  refresh() {

    // This parameters are easier to manage
    const params = new RequestOptions({
      search: {
        fromCurrency: this.initialKey,
        toCurrency: this.finalKey,
        amount: this.initialValue
      }
    })

    // Note the second argument 'params'
    this.http.get('http://localhost:5000/converter/convert', params).subscribe((val) => {
      this.value = val.json();
      this.finalValue = this.value.convertedAmount;

      // If we got to here successfuly, it means there was no error, so we clear the error string
      this.lastError = '';
    }, (response: Response) => {
      // If we got something from backend useful, we display that string, otherwise
      //   we use statusText, which contains human-readable error generated by angular.
      if (response.text() && response.text().length > 0) {
        this.lastError = response.text();
      } else {
        this.lastError = response.statusText;
      }
      // Response status 0 is a special case when either server is unavailable or
      //   user is disconnected from the internet. We do not get any useful information
      //   in response body nor response status text.
      if (response.status === 0) {
        this.lastError = 'Server could not be reached';
      }
    });
  }
}
